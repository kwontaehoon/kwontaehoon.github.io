---
layout : archive
title : Jotai
categories : React
date : 2025-06-18
---

## Jotai

React에서 사용가능한 아주 간단한 atomic 상태 라이브러리


### Jotai를 왜 사용하는가?



### Jotai의 주요 개념

1. Atom

- 읽기 전용 atom
```javascript
// read + write
const countAtom = atom(10)

// readOnly
const doubleCountAtom = atom((get) => get(countAtom) * 2)
```
- 쓰기 전용 atom
```javascript
// writeOnly
export const incrementAtom = atom(null, (get, set, update) => {
    set(countAtom, get(countAtom) + 1)
})
```
- 읽기 + 쓰기 atom
```javascript
const countAtom = atom(10)
```

2. useAtom은 원자를 읽는데 사용하며 write 함수(setState)가 추가됩니다.
```javascript
const [value, setValue] = useAtom(countAtom)
```

- useAtomValue와 useSetAtom
```javascript
const count = useAtomValue(countAtom)
const setCount  = useSetAtom(countAtom)
```

> why? useAtomValue와 useSetAtom을 왜 나눠서 사용할까?

useAtomValue()만 쓰면 해당 atom의 값이 변경될 때만 리렌더링되지만
useSetAtom()만 쓰면 값 변화에 영향을 받지 않고 리렌더링이 되지않기 때문입니다.

```javascript
function ReadOnlyFunc() {
    const count = useAtomValue(countAtom); // 값만 읽음
    console.log('ReadOnly 렌더링');
    return <div>Count: {count}</div>;
}

function WriteOnlyFunc() {
    const increment = useSetAtom(countAtom); // 값은 읽지 않음
    console.log('WriteOnly 렌더링');
    return <button onClick={() => increment((prev) => prev + 1)}>+1</button>;
    // 버튼을 누르면 ReadOnlyFunc만 리렌더링이 발생합니다.
}

function MyApp() {
    return(
        <>
            <ReadOnlyFunc />
            <WriteOnlyFunc />
        </>
    )
}
```

3. atomWithStorage의 기본 저장소는 localStorage입니다.
```javascript
const darkModeAtom = atomWithStorage('darkMode', false)
function MyApp() {
    
    return(
        <>
        <h1>Welcome to {darkMode ? 'dark' : 'light'} mode!</h1>

        {/* setState */}
        <button onClick={() => setDarkMode(!darkMode)}>toggle theme</button>

        {/* reset */}
        <button onClick={() => setDarkMode(RESET)}>Reset (to 'hello')</button>

        {/* setState or reset*/}
        <button onClick={() => setIsVisible((prev) => prev ? RESET : true)}>Toggle visible</button>
        </>
    )
}
```

4. useHydrateAtoms를 사용하여 렌더링시 서버에서 준비한 값으로 초기값을 변경할 수 있습니다.
```javascript
const hydrateAtom = atom(0)

//server
export default async function Server() {

    const res = await fetch('http://localhost:8080/api/test2?page=0', {
        cache: 'no-store'
      });
    const data = await res.json();

    return(
        <Client data={data} />
    )
}

// client
function MyApp({ data }) {
    useHydrateAtoms([
    [hydrateAtom, data],
  ])
}
```

5. 비동기 atom을 관리하는 loadable
```javascript
const asyncAtom = atom(async (get) => await fetch('http://localhost:8080/api/test2?page=0', {
    cache: 'no-store'
}))

const loadableAtom = loadable(asyncAtom)

function MyApp() {
    const [value] = useAtom(loadableAtom)

    if (value.state === 'hasError') return <Text>{value.error}</Text>
    if (value.state === 'loading') {
        return <Text>Loading...</Text>
    }

    return <Text>Value: {value.data}</Text>
}
```



6. Observable 기반 데이터 소스와 atom을 연결할 때 사용하는 atomWithObservable
두번째 매개변수를 사용하여 초기값을 지정할 수 있습니다.
```javascript
const counterSubject = interval(1000).pipe(map((i) => `#${i}`))
const counterAtom = atomWithObservable(() => counterSubject, {
    initialValue: 10
})

const Counter = () => {
  const [counter] = useAtom(counterAtom)
  return <div>count: {counter}</div>
}
```

> what? Observable

시간에 따라 전달되는 여러 개의 값을 처리할 수 있는 스트림 객체로 연속적인 이벤트를 처리할 때 유용합니다.

<br />

7. asyncAtom과 다르게 최초 1회만 초기화하며 의존성이 필요 없을 때 atomWithLazy를 사용합니다.
```javascript

const pageAtom = atom(1);

const asyncAtom = atom(async (get) => {
  const page = get(pageAtom); // pageAtom 값이 바뀌면 다시 요청됨
  const res = await fetch(`/api/data?page=${page}`)
  return res.json()
});

// 외부 상태 변화와 관계없이 1회 초기화
const lazyAtom = atomWithLazy(async () => {
  const res = await fetch(`/api/data?page=1`)
  return res.json()
})
```
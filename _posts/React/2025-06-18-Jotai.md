---
layout : archive
title : Jotai
categories : React
date : 2025-06-18
---

## Jotai

React에서 사용가능한 아주 간단한 atomic 상태 라이브러리


### Jotai를 왜 사용하는가?



### Jotai의 주요 개념

1. Atom

- 읽기 전용 atom
```javascript
// read + write
const countAtom = atom(10)

// readOnly
const doubleCountAtom = atom((get) => get(countAtom) * 2)
```
- 쓰기 전용 atom
```javascript
// writeOnly
export const incrementAtom = atom(null, (get, set, update) => {
    set(countAtom, get(countAtom) + 1)
})
```
- 읽기 + 쓰기 atom
```javascript
const countAtom = atom(10)
```

2. useAtom은 원자를 읽는데 사용하며 write 함수(setState)가 추가됩니다.
```javascript
const [value, setValue] = useAtom(countAtom)
```

- useAtomValue와 useSetAtom
```javascript
const count = useAtomValue(countAtom)
const setCount  = useSetAtom(countAtom)
```

> why? useAtomValue와 useSetAtom을 왜 나눠서 사용할까?

useAtomValue()만 쓰면 해당 atom의 값이 변경될 때만 리렌더링되지만
useSetAtom()만 쓰면 값 변화에 영향을 받지 않고 리렌더링이 되지않기 때문입니다.

```javascript
function ReadOnlyFunc() {
    const count = useAtomValue(countAtom); // 값만 읽음
    console.log('ReadOnly 렌더링');
    return <div>Count: {count}</div>;
}

function WriteOnlyFunc() {
    const increment = useSetAtom(countAtom); // 값은 읽지 않음
    console.log('WriteOnly 렌더링');
    return <button onClick={() => increment((prev) => prev + 1)}>+1</button>;
    // 버튼을 누르면 ReadOnlyFunc만 리렌더링이 발생합니다.
}

function MyApp() {
    return(
        <>
            <ReadOnlyFunc />
            <WriteOnlyFunc />
        </>
    )
}
```

3. atomWithStorage의 기본 저장소는 localStorage입니다.
```javascript
const darkModeAtom = atomWithStorage('darkMode', false)
function MyApp() {
    
    return(
        <>
        <h1>Welcome to {darkMode ? 'dark' : 'light'} mode!</h1>

        {/* setState */}
        <button onClick={() => setDarkMode(!darkMode)}>toggle theme</button>

        {/* reset */}
        <button onClick={() => setDarkMode(RESET)}>Reset (to 'hello')</button>

        {/* setState or reset*/}
        <button onClick={() => setIsVisible((prev) => prev ? RESET : true)}>Toggle visible</button>
        </>
    )
}
```

4. useHydrateAtoms를 사용하여 렌더링시 서버에서 준비한 값으로 초기값을 변경할 수 있습니다.
```javascript
const hydrateAtom = atom(0)

//server
export default async function Server() {

    const res = await fetch('http://localhost:8080/api/test2?page=0', {
        cache: 'no-store'
      });
    const data = await res.json();

    return(
        <Client data={data} />
    )
}

// client
function MyApp({ data }) {
    useHydrateAtoms([
    [hydrateAtom, data],
  ])
}
```

5. 비동기 atom을 관리하는 loadable
```javascript
const asyncAtom = atom(async (get) => await fetch('http://localhost:8080/api/test2?page=0', {
    cache: 'no-store'
}))

const loadableAtom = loadable(asyncAtom)

function MyApp() {
    const [value] = useAtom(loadableAtom)

    if (value.state === 'hasError') return <Text>{value.error}</Text>
    if (value.state === 'loading') {
        return <Text>Loading...</Text>
    }

    return <Text>Value: {value.data}</Text>
}
```



6. Observable 기반 데이터 소스와 atom을 연결할 때 사용하는 atomWithObservable
두번째 매개변수를 사용하여 초기값을 지정할 수 있습니다.
```javascript
const counterSubject = interval(1000).pipe(map((i) => `#${i}`))
const counterAtom = atomWithObservable(() => counterSubject, {
    initialValue: 10
})

const Counter = () => {
  const [counter] = useAtom(counterAtom)
  return <div>count: {counter}</div>
}
```

> what? Observable

시간에 따라 전달되는 여러 개의 값을 처리할 수 있는 스트림 객체로 연속적인 이벤트를 처리할 때 유용합니다.

<br />

7. asyncAtom과 다르게 최초 1회만 초기화하며 의존성이 필요 없을 때 atomWithLazy를 사용합니다.
```javascript

const pageAtom = atom(1);

const asyncAtom = atom(async (get) => {
  const page = get(pageAtom); // pageAtom 값이 바뀌면 다시 요청됨
  const res = await fetch(`/api/data?page=${page}`)
  return res.json()
});

// 외부 상태 변화와 관계없이 1회 초기화
const lazyAtom = atomWithLazy(async () => {
  const res = await fetch(`/api/data?page=1`)
  return res.json()
})
```

8. atom 리셋에 필요한 atomWithReset와 useResetAtom
```javascript
// atomWithReset
const dollarsAtom = atomWithReset(0)
const centsAtom = atom(
  (get) => get(dollarsAtom) * 100,
  (get, set, newValue: number | typeof RESET) => {
    return set(dollarsAtom, newValue === RESET ? newValue : newValue / 100)
  }
)

function MyApp() {
    const resetCents = useResetAtom(centsAtom)
    // centsAtom 은 dollarsAtom을 구독하고있기 때문에 dollarsAtom이 리셋되면 centsAtom도 리셋됩니다.
    return(...)
}
```

9. 기본값만 계산식 기반으로 설정하고, 사용자가 값을 직접 바꾸거나 다시 초기화할 수 있는 atomWithDefault
```javascript
const count1Atom = atom(1)
const count2Atom = atomWithDefault((get) => get(count1Atom) * 2)

function MyApp() {
    const [count1, setCount1] = useAtom(count1Atom)
    const [count2, setCount2] = useAtom(count2Atom)
    const resetCount2 = useResetAtom(count2Atom)
}
```

10. 비동기 데이터를 새로 고쳐야할 때 유용한 atomWithRefresh를 사용하며 "당겨서 새로고침" 기능 등을 구현하는데 사용할 수 있습니다.
```javascript
const postsAtom = atomWithRefresh((get) =>
  fetch('https://jsonplaceholder.typicode.com/posts').then((r) => r.json()),
)

const PostsList = () => {
  const [posts, refreshPosts] = useAtom(postsAtom)

  return (
    <div>
      <ul>
        {posts.slice(0, 5)map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>

      {/* Clicking this button will re-fetch the posts */}
      <button type="button" onClick={() => refreshPosts()}>
        Refresh posts
      </button>
    </div>
  )
}
```

11. parameter에 따라 서로 독립적인 atom을 생성 가능한 atomFamily
```javascript
import Child from './Child'

const todoAtomFamily = atomFamily((id: number) =>
    atom(`Todo item ${id}`) // id별로 다른 atom 생성
)

const MyApp = () => {

    return (
        <div>
            {[1,2,3].map((id) => {
                <Child key={id} id={id}>
            })}
        </div>
    )
}

const Child = ({id}: {id: number }) => {
    const [text, setText] = useAtom(todoAtomFamily(id))

  return (
    <div className='mb-2'>
      <input
        className='border px-2 py-1'
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
    </div>
  )
}
```

[출처] https://jotai.org